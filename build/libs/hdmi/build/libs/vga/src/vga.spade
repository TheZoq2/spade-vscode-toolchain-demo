struct VgaTiming {
    x_pixels: int<15>,
    x_front_porch: int<11>,
    x_sync_width: int<11>,
    x_back_porch: int<11>,

    y_pixels: int<15>,
    y_front_porch: int<11>,
    y_sync_width: int<11>,
    y_back_porch: int<11>,
}

/// Generate a VGA signal with the specified timing in pixel clock cycles.
/// The pixel clock is generated by `clk` and `clock_enable`. Every cycle
/// in which `clock_enable` is true, the pixel is incremented.
///
/// For example, to generate a 25 MHz VGA signal from a 100 MHz system clock:
///
/// ```spade
/// reg(clk) clk_div: int<2> reset(rst: 0) = trunc(clk_div + 1);
/// inst vga_fsm(clk, rst, clk_div == 0);
/// ```
entity vga_fsm(clk: clock, rst: bool, clk_enable: bool, timing: VgaTiming) -> VgaState {
    let (next_y, x_state) = inst vga_partial_fsm(
        clk,
        rst,
        clk_enable,
        timing.x_front_porch,
        timing.x_pixels,
        timing.x_sync_width,
        timing.x_back_porch
    );

    let (_, y_state) = inst vga_partial_fsm(
        clk,
        rst,
        next_y,
        timing.y_front_porch,
        timing.y_pixels,
        timing.y_sync_width,
        timing.y_back_porch
    );

    VgaState$(x: x_state, y: y_state)
}


entity vga_frame_done(state: (VgaPartialState, VgaPartialState)) -> bool {
    match state {
        (VgaPartialState::FrontPorch(0), VgaPartialState::FrontPorch(0)) => {
            true
        },
        _ => false
    }
}

struct VgaOutput<T> {
    hsync: bool,
    vsync: bool,
    blank: bool,
    pixel: T
}

struct VgaState {
    x: VgaPartialState,
    y: VgaPartialState
}

fn vga_output(vga_state: VgaState) -> VgaOutput<Option<(int<15>, int<15>)>> {
    let pixel = match vga_state {
        VgaState$(x: VgaPartialState::Active(x), y: VgaPartialState::Active(y)) => Some((x, y)),
        _ => None()
    };

    let hsync = match vga_state.x {
        VgaPartialState::Sync(_) => true,
        _ => false
    };

    let vsync = match vga_state.y {
        VgaPartialState::Sync(_) => true,
        _ => false
    };

    let blank = match pixel {
        Some(_) => false,
        None => true
    };

    VgaOutput$(hsync, vsync, blank, pixel)
}


// Private implementation details

enum VgaPartialState {
    BackPorch { duration: int<11> },
    Active { duration: int<15> },
    FrontPorch { duration: int<11> },
    Sync { duration: int<11> },
}

entity vga_partial_fsm(
    clk: clock,
    rst: bool,
    // True if this should tick over to the next state
    next_state: bool,
    // Timings
    front_porch: int<11>,
    active: int<15>,
    sync: int<11>,
    back_porch: int<11>,
) -> (bool, VgaPartialState) {
    reg(clk) state reset(rst: VgaPartialState::Active(0)) = {
        if next_state {
            match state {
                VgaPartialState::BackPorch(duration) => {
                    if duration == trunc(back_porch - 1) {
                        VgaPartialState::Active(0)
                    }
                    else {
                        VgaPartialState::BackPorch(trunc(duration + 1))
                    }
                },
                VgaPartialState::Active(duration) => {
                    if duration == trunc(active - 1) {
                        VgaPartialState::FrontPorch(0)
                    }
                    else {
                        VgaPartialState::Active(trunc(duration + 1))
                    }
                },
                VgaPartialState::FrontPorch(duration) => {
                    if duration == trunc(front_porch - 1) {
                        VgaPartialState::Sync(0)
                    }
                    else {
                        VgaPartialState::FrontPorch(trunc(duration + 1))
                    }
                },
                VgaPartialState::Sync(duration) => {
                    if duration == trunc(sync - 1) {
                        VgaPartialState::BackPorch(0)
                    }
                    else {
                        VgaPartialState::Sync(trunc(duration + 1))
                    }
                },
            }
        }
        else {
            state
        }
    };

    let carry_out = match state {
        VgaPartialState::Sync(duration) => {
            if duration == trunc(sync - 1) {
                next_state
            }
            else {
                false
            }
        },
        _ => false
    };

    (carry_out, state)
}

