entity \std::conv::bit_to_bool ((b, b, bool)) -> bool {
	let e1: bool = ZeroExtend(0)(b)
} => e1

entity \std::conv::unsafe::clock_to_bool ((c, c, bool)) -> bool {
	let e22: bool = ZeroExtend(0)(c)
} => e22

entity \std::conv::unsafe::bool_to_clock ((c, c, bool)) -> bool {
	let e25: bool = ZeroExtend(0)(c)
} => e25

entity \std::io::rising_edge ((clk, clk, bool), (sync1, sync1, bool)) -> bool {
	reg(clk) sync2: bool = sync1
	let e33: bool = Not(sync2)
	let e31: bool = LogicalAnd(sync1, e33)
} => e31

entity \std::io::falling_edge ((clk, clk, bool), (sync1, sync1, bool)) -> bool {
	reg(clk) sync2: bool = sync1
	let e41: bool = Not(sync1)
	let e39: bool = LogicalAnd(sync2, e41)
} => e39

entity \std::cdc::sync2_bool ((clk, clk, bool), (in, in, bool)) -> bool {
	let e335: bool = Instance(\std::cdc::unsafe::sync2[497] )(clk, in)
} => e335

entity top((#[no_mangle]clk_25mhz, clk_25mhz, bool), (#[no_mangle]gpdi_dp, gpdi_dp, &mut ([bool; 4]))) -> void {
	let e622: {clk_pixel: bool, clk_shift: bool} = Instance(pll_480_800_60)(clk_25mhz)
	let vga_clk: bool = IndexTuple(0, [Bool, Bool])(e622)
	let clk_shift: bool = IndexTuple(1, [Bool, Bool])(e622)
	const e625: bool = true
	const e626: bool = false
	reg(vga_clk) rst: boolinitial(const e625: bool = true) = e626
	const e627: int<15> = 480
	let x_pixels: int<15> = Alias(e627)
	const e629: int<15> = 800
	let y_pixels: int<15> = Alias(e629)
	const e633: int<11> = 24
	const e634: int<11> = 48
	const e635: int<11> = 72
	const e637: int<11> = 3
	const e638: int<11> = 10
	const e639: int<11> = 18
	let timing: {x_pixels: int<15>, x_front_porch: int<11>, x_sync_width: int<11>, x_back_porch: int<11>, y_pixels: int<15>, y_front_porch: int<11>, y_sync_width: int<11>, y_back_porch: int<11>} = ConstructTuple(x_pixels, e633, e634, e635, y_pixels, e637, e638, e639)
	const e644: bool = true
	let vga_state: {x: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>], y: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]} = Instance(\vga::vga::vga_fsm )(vga_clk, rst, e644, timing)
	let e653: {hsync: bool, vsync: bool, blank: bool, pixel: enum option [(int<15>, int<15>)], option []} = Instance(\vga::vga::vga_output )(vga_state)
	let hsync: bool = IndexTuple(0, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e653)
	let vsync: bool = IndexTuple(1, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e653)
	let blank: bool = IndexTuple(2, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e653)
	let pixel: enum option [(int<15>, int<15>)], option [] = IndexTuple(3, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e653)
	let e658: (int<15>, int<15>) = EnumMember(0 0)(pixel)
	let x: int<15> = IndexTuple(0, [Int(15), Int(15)])(e658)
	let y: int<15> = IndexTuple(1, [Int(15), Int(15)])(e658)
	let e1148: bool = IsEnumVariant(0)(pixel)
	const e1150: bool = true
	const e1151: bool = true
	let e1152: bool = LogicalAnd(e1150, e1151)
	let e1153: bool = LogicalAnd(e1148, e1152)
	let e662: int<8> = Truncate(x)
	let e664: int<8> = Truncate(y)
	let e667: bool = Gt(x, y)
	const e671: int<8> = 127
	const e673: int<8> = 0
	let e666: int<8> = Select(e667, e671, e673)
	let e661: (int<8>, int<8>, int<8>) = ConstructTuple(e662, e664, e666)
	let e1155: bool = IsEnumVariant(1)(pixel)
	const e677: int<8> = 0
	const e678: int<8> = 0
	const e679: int<8> = 0
	let e676: (int<8>, int<8>, int<8>) = ConstructTuple(e677, e678, e679)
	let color: (int<8>, int<8>, int<8>) = Match(e1153, e661, e1155, e676)
	let dvi: {r: int<2>, g: int<2>, b: int<2>, clock: int<2>} = Instance(\hdmi::vga2dvid::vga2dvid )(vga_clk, clk_shift, rst, hsync, vsync, blank, color)
	const e694: bool = false
	let e695: int<2> = IndexTuple(2, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e692: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e694, e695)
	const e699: bool = false
	let e700: int<2> = IndexTuple(1, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e697: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e699, e700)
	const e704: bool = false
	let e705: int<2> = IndexTuple(0, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e702: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e704, e705)
	const e709: bool = false
	let e710: int<2> = IndexTuple(3, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e707: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e709, e710)
	let e691: [bool; 4] = ConstructArray(e692, e697, e702, e707)
	set gpdi_dp = e691
} => e617

entity \vga::vga::vga_fsm ((clk, clk, bool), (rst, rst, bool), (clk_enable, clk_enable, bool), (timing, timing, {x_pixels: int<15>, x_front_porch: int<11>, x_sync_width: int<11>, x_back_porch: int<11>, y_pixels: int<15>, y_front_porch: int<11>, y_sync_width: int<11>, y_back_porch: int<11>})) -> {x: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>], y: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]} {
	let e717: int<11> = IndexTuple(1, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e719: int<15> = IndexTuple(0, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e721: int<11> = IndexTuple(2, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e723: int<11> = IndexTuple(3, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e727: (bool, enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]) = Instance(\vga::vga::vga_partial_fsm )(clk, rst, clk_enable, e717, e719, e721, e723)
	let next_y: bool = IndexTuple(0, [Bool, Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(e727)
	let x_state: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(1, [Bool, Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(e727)
	let e732: int<11> = IndexTuple(5, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e734: int<15> = IndexTuple(4, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e736: int<11> = IndexTuple(6, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e738: int<11> = IndexTuple(7, [Int(15), Int(11), Int(11), Int(11), Int(15), Int(11), Int(11), Int(11)])(timing)
	let e742: (bool, enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]) = Instance(\vga::vga::vga_partial_fsm )(clk, rst, next_y, e732, e734, e736, e738)
	let _: bool = IndexTuple(0, [Bool, Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(e742)
	let y_state: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(1, [Bool, Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(e742)
	let e743: {x: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>], y: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]} = ConstructTuple(x_state, y_state)
} => e743

entity \vga::vga::vga_frame_done ((state, state, (enum option [int<11>], option [int<15>], option [int<11>], option [int<11>], enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]))) -> bool {
	let e750: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(0, [Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]]), Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(state)
	let e749: int<11> = EnumMember(2 0)(e750)
	let e752: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(1, [Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]]), Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(state)
	let e751: int<11> = EnumMember(2 0)(e752)
	let e1158: bool = IsEnumVariant(2)(e750)
	const e1160: int<11> = 0
	let e1159: bool = Eq(e749, e1160)
	let e1161: bool = LogicalAnd(e1158, e1159)
	let e1163: bool = IsEnumVariant(2)(e752)
	const e1165: int<11> = 0
	let e1164: bool = Eq(e751, e1165)
	let e1166: bool = LogicalAnd(e1163, e1164)
	let e1167: bool = LogicalAnd(e1161, e1166)
	const e755: bool = true
	const e1168: bool = true
	const e757: bool = false
	let e747: bool = Match(e1167, e755, e1168, e757)
} => e747

entity \vga::vga::vga_output ((vga_state, vga_state, {x: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>], y: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]})) -> {hsync: bool, vsync: bool, blank: bool, pixel: enum option [(int<15>, int<15>)], option []} {
	let e762: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(0, [Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]]), Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(vga_state)
	let x: int<15> = EnumMember(1 0)(e762)
	let e764: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(1, [Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]]), Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(vga_state)
	let y: int<15> = EnumMember(1 0)(e764)
	const e1170: bool = true
	let e1172: bool = IsEnumVariant(1)(e762)
	const e1173: bool = true
	let e1174: bool = LogicalAnd(e1172, e1173)
	let e1176: bool = IsEnumVariant(1)(e764)
	const e1177: bool = true
	let e1178: bool = LogicalAnd(e1176, e1177)
	let e1179: bool = LogicalAnd(e1170, e1174)
	let e1180: bool = LogicalAnd(e1179, e1178)
	let e767: (int<15>, int<15>) = ConstructTuple(x, y)
	let e766: enum option [(int<15>, int<15>)], option [] = ConstructEnum(0, 2)(e767)
	const e1181: bool = true
	let e771: enum option [(int<15>, int<15>)], option [] = ConstructEnum(1, 2)()
	let pixel: enum option [(int<15>, int<15>)], option [] = Match(e1180, e766, e1181, e771)
	let e774: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(0, [Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]]), Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(vga_state)
	let _: int<11> = EnumMember(3 0)(e774)
	let e1183: bool = IsEnumVariant(3)(e774)
	const e1184: bool = true
	let e1185: bool = LogicalAnd(e1183, e1184)
	const e778: bool = true
	const e1186: bool = true
	const e780: bool = false
	let hsync: bool = Match(e1185, e778, e1186, e780)
	let e783: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = IndexTuple(1, [Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]]), Enum([[Int(11)], [Int(15)], [Int(11)], [Int(11)]])])(vga_state)
	let __n1: int<11> = EnumMember(3 0)(e783)
	let e1188: bool = IsEnumVariant(3)(e783)
	const e1189: bool = true
	let e1190: bool = LogicalAnd(e1188, e1189)
	const e787: bool = true
	const e1191: bool = true
	const e789: bool = false
	let vsync: bool = Match(e1190, e787, e1191, e789)
	let __n2: (int<15>, int<15>) = EnumMember(0 0)(pixel)
	let e1193: bool = IsEnumVariant(0)(pixel)
	const e1194: bool = true
	let e1195: bool = LogicalAnd(e1193, e1194)
	const e795: bool = false
	let e1197: bool = IsEnumVariant(1)(pixel)
	const e797: bool = true
	let blank: bool = Match(e1195, e795, e1197, e797)
	let e799: {hsync: bool, vsync: bool, blank: bool, pixel: enum option [(int<15>, int<15>)], option []} = ConstructTuple(hsync, vsync, blank, pixel)
} => e799

entity \vga::vga::vga_partial_fsm ((clk, clk, bool), (rst, rst, bool), (next_state, next_state, bool), (front_porch, front_porch, int<11>), (active, active, int<15>), (sync, sync, int<11>), (back_porch, back_porch, int<11>)) -> (bool, enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]) {
	const e809: int<15> = 0
	let e808: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(1, 4)(e809)
	let duration: int<11> = EnumMember(0 0)(state)
	let e1199: bool = IsEnumVariant(0)(state)
	const e1200: bool = true
	let e1201: bool = LogicalAnd(e1199, e1200)
	const e825: int<11> = 1
	let e823: int<12> = Sub(back_porch, e825)
	let e822: int<11> = Truncate(e823)
	let e820: bool = Eq(duration, e822)
	const e828: int<15> = 0
	let e827: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(1, 4)(e828)
	const e834: int<11> = 1
	let e832: int<12> = Add(duration, e834)
	let e831: int<11> = Truncate(e832)
	let e830: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(0, 4)(e831)
	let e819: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = Select(e820, e827, e830)
	let duration_n1: int<15> = EnumMember(1 0)(state)
	let e1203: bool = IsEnumVariant(1)(state)
	const e1204: bool = true
	let e1205: bool = LogicalAnd(e1203, e1204)
	const e844: int<15> = 1
	let e842: int<16> = Sub(active, e844)
	let e841: int<15> = Truncate(e842)
	let e839: bool = Eq(duration_n1, e841)
	const e847: int<11> = 0
	let e846: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(2, 4)(e847)
	const e853: int<15> = 1
	let e851: int<16> = Add(duration_n1, e853)
	let e850: int<15> = Truncate(e851)
	let e849: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(1, 4)(e850)
	let e838: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = Select(e839, e846, e849)
	let duration_n2: int<11> = EnumMember(2 0)(state)
	let e1207: bool = IsEnumVariant(2)(state)
	const e1208: bool = true
	let e1209: bool = LogicalAnd(e1207, e1208)
	const e863: int<11> = 1
	let e861: int<12> = Sub(front_porch, e863)
	let e860: int<11> = Truncate(e861)
	let e858: bool = Eq(duration_n2, e860)
	const e866: int<11> = 0
	let e865: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(3, 4)(e866)
	const e872: int<11> = 1
	let e870: int<12> = Add(duration_n2, e872)
	let e869: int<11> = Truncate(e870)
	let e868: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(2, 4)(e869)
	let e857: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = Select(e858, e865, e868)
	let duration_n3: int<11> = EnumMember(3 0)(state)
	let e1211: bool = IsEnumVariant(3)(state)
	const e1212: bool = true
	let e1213: bool = LogicalAnd(e1211, e1212)
	const e882: int<11> = 1
	let e880: int<12> = Sub(sync, e882)
	let e879: int<11> = Truncate(e880)
	let e877: bool = Eq(duration_n3, e879)
	const e885: int<11> = 0
	let e884: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(0, 4)(e885)
	const e891: int<11> = 1
	let e889: int<12> = Add(duration_n3, e891)
	let e888: int<11> = Truncate(e889)
	let e887: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = ConstructEnum(3, 4)(e888)
	let e876: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = Select(e877, e884, e887)
	let e814: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = Match(e1201, e819, e1205, e838, e1209, e857, e1213, e876)
	let e811: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>] = Select(next_state, e814, state)
	reg(clk) state: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>](rst, e808) = e811
	let duration_n4: int<11> = EnumMember(3 0)(state)
	let e1215: bool = IsEnumVariant(3)(state)
	const e1216: bool = true
	let e1217: bool = LogicalAnd(e1215, e1216)
	const e905: int<11> = 1
	let e903: int<12> = Sub(sync, e905)
	let e902: int<11> = Truncate(e903)
	let e900: bool = Eq(duration_n4, e902)
	const e909: bool = false
	let e899: bool = Select(e900, next_state, e909)
	const e1218: bool = true
	const e911: bool = false
	let carry_out: bool = Match(e1217, e899, e1218, e911)
	let e913: (bool, enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]) = ConstructTuple(carry_out, state)
} => e913

entity \hdmi::ecp5stubs::oddrx1f ((sclk, sclk, bool), (rst, rst, bool), (d, d, int<2>)) -> bool {
	let o: &mut (bool) = Nop()
	const e923: int<2> = 1
	let e921: int<2> = BitwiseAnd(d, e923)
	const e924: int<2> = 1
	let e920: bool = Eq(e921, e924)
	const e929: int<2> = 1
	let e927: int<2> = RightShift(d, e929)
	const e930: int<2> = 1
	let e926: int<2> = BitwiseAnd(e927, e930)
	const e931: int<2> = 1
	let e925: bool = Eq(e926, e931)
	let _: void = Instance(ODDRX1F)(sclk, rst, e920, e925, o)
	let e936: bool = ReadPort(o)
} => e936

entity \hdmi::main::main ((#[no_mangle]clk_25mhz, clk_25mhz, bool), (#[no_mangle]gpdi_dp, gpdi_dp, &mut ([bool; 4]))) -> void {
	let e943: {clk_pixel: bool, clk_shift: bool} = Instance(pll_480_800_60)(clk_25mhz)
	let vga_clk: bool = IndexTuple(0, [Bool, Bool])(e943)
	let clk_shift: bool = IndexTuple(1, [Bool, Bool])(e943)
	const e946: bool = true
	const e947: bool = false
	reg(vga_clk) rst: boolinitial(const e946: bool = true) = e947
	const e948: int<15> = 480
	let x_pixels: int<15> = Alias(e948)
	const e950: int<15> = 800
	let y_pixels: int<15> = Alias(e950)
	const e954: int<11> = 24
	const e955: int<11> = 48
	const e956: int<11> = 72
	const e958: int<11> = 3
	const e959: int<11> = 10
	const e960: int<11> = 18
	let timing: {x_pixels: int<15>, x_front_porch: int<11>, x_sync_width: int<11>, x_back_porch: int<11>, y_pixels: int<15>, y_front_porch: int<11>, y_sync_width: int<11>, y_back_porch: int<11>} = ConstructTuple(x_pixels, e954, e955, e956, y_pixels, e958, e959, e960)
	const e965: bool = true
	let vga_state: {x: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>], y: enum option [int<11>], option [int<15>], option [int<11>], option [int<11>]} = Instance(\vga::vga::vga_fsm )(vga_clk, rst, e965, timing)
	let e974: {hsync: bool, vsync: bool, blank: bool, pixel: enum option [(int<15>, int<15>)], option []} = Instance(\vga::vga::vga_output )(vga_state)
	let hsync: bool = IndexTuple(0, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e974)
	let vsync: bool = IndexTuple(1, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e974)
	let blank: bool = IndexTuple(2, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e974)
	let pixel: enum option [(int<15>, int<15>)], option [] = IndexTuple(3, [Bool, Bool, Bool, Enum([[Tuple([Int(15), Int(15)])], []])])(e974)
	let e979: (int<15>, int<15>) = EnumMember(0 0)(pixel)
	let x: int<15> = IndexTuple(0, [Int(15), Int(15)])(e979)
	let y: int<15> = IndexTuple(1, [Int(15), Int(15)])(e979)
	let e1220: bool = IsEnumVariant(0)(pixel)
	const e1222: bool = true
	const e1223: bool = true
	let e1224: bool = LogicalAnd(e1222, e1223)
	let e1225: bool = LogicalAnd(e1220, e1224)
	let e983: int<8> = Truncate(x)
	let e985: int<8> = Truncate(y)
	let e988: bool = Gt(x, y)
	const e992: int<8> = 127
	const e994: int<8> = 0
	let e987: int<8> = Select(e988, e992, e994)
	let e982: (int<8>, int<8>, int<8>) = ConstructTuple(e983, e985, e987)
	let e1227: bool = IsEnumVariant(1)(pixel)
	const e998: int<8> = 0
	const e999: int<8> = 0
	const e1000: int<8> = 0
	let e997: (int<8>, int<8>, int<8>) = ConstructTuple(e998, e999, e1000)
	let color: (int<8>, int<8>, int<8>) = Match(e1225, e982, e1227, e997)
	let dvi: {r: int<2>, g: int<2>, b: int<2>, clock: int<2>} = Instance(\hdmi::vga2dvid::vga2dvid )(vga_clk, clk_shift, rst, hsync, vsync, blank, color)
	const e1015: bool = false
	let e1016: int<2> = IndexTuple(2, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e1013: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e1015, e1016)
	const e1020: bool = false
	let e1021: int<2> = IndexTuple(1, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e1018: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e1020, e1021)
	const e1025: bool = false
	let e1026: int<2> = IndexTuple(0, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e1023: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e1025, e1026)
	const e1030: bool = false
	let e1031: int<2> = IndexTuple(3, [Int(2), Int(2), Int(2), Int(2)])(dvi)
	let e1028: bool = Instance(\hdmi::ecp5stubs::oddrx1f )(clk_shift, e1030, e1031)
	let e1012: [bool; 4] = ConstructArray(e1013, e1018, e1023, e1028)
	set gpdi_dp = e1012
} => e938

entity \hdmi::vga2dvid::vga2dvid ((clk_pixel, clk_pixel, bool), (clk_shift, clk_shift, bool), (rst, rst, bool), (hsync, hsync, bool), (vsync, vsync, bool), (blank, blank, bool), (color, color, (int<8>, int<8>, int<8>))) -> {r: int<2>, g: int<2>, b: int<2>, clock: int<2>} {
	const e1034: int<2> = 1
	let one: int<2> = Alias(e1034)
	let e1039: int<1> = Truncate(one)
	const e1042: int<1> = 0
	let hsync_int: int<1> = Select(hsync, e1039, e1042)
	let e1047: int<1> = Truncate(one)
	const e1050: int<1> = 0
	let vsync_int: int<1> = Select(vsync, e1047, e1050)
	const e1052: int<2> = 0
	let c_red: int<2> = Alias(e1052)
	const e1054: int<2> = 0
	let c_green: int<2> = Alias(e1054)
	let c_blue: int<2> = Concat(vsync_int, hsync_int)
	let r: int<8> = IndexTuple(0, [Int(8), Int(8), Int(8)])(color)
	let g: int<8> = IndexTuple(1, [Int(8), Int(8), Int(8)])(color)
	let b: int<8> = IndexTuple(2, [Int(8), Int(8), Int(8)])(color)
	let encoded_red: int<10> = Instance(tmds_encoder_wrapper)(clk_pixel, r, c_red, blank)
	let encoded_green: int<10> = Instance(tmds_encoder_wrapper)(clk_pixel, g, c_green, blank)
	let encoded_blue: int<10> = Instance(tmds_encoder_wrapper)(clk_pixel, b, c_blue, blank)
	let e1085: (int<10>, int<10>, int<10>) = ConstructTuple(encoded_red, encoded_green, encoded_blue)
	reg(clk_pixel) latched_pixels: (int<10>, int<10>, int<10>) = e1085
	const e1089: int<10> = 31
	let shift_clock_initial: int<10> = Alias(e1089)
	let upper: int<2> = Truncate(shift_clock)
	const e1102: int<10> = 2
	let e1100: int<10> = RightShift(shift_clock, e1102)
	let rest: int<8> = Truncate(e1100)
	let e1104: int<10> = Concat(upper, rest)
	reg(clk_shift) shift_clock: int<10>(rst, shift_clock_initial) = e1104
	const e1116: int<10> = 4
	let e1114: int<10> = RightShift(shift_clock, e1116)
	let shift_comp: int<2> = Truncate(e1114)
	const e1124: int<10> = 4
	let e1122: int<10> = RightShift(shift_clock_initial, e1124)
	let e1121: int<2> = Truncate(e1122)
	let e1119: bool = Eq(shift_comp, e1121)
	const e1131: int<10> = 2
	let e1129: int<10> = RightShift(shift_red, e1131)
	const e1134: int<10> = 2
	let e1132: int<10> = RightShift(shift_green, e1134)
	const e1137: int<10> = 2
	let e1135: int<10> = RightShift(shift_blue, e1137)
	let e1128: (int<10>, int<10>, int<10>) = ConstructTuple(e1129, e1132, e1135)
	let e1118: (int<10>, int<10>, int<10>) = Select(e1119, latched_pixels, e1128)
	reg(clk_shift) e1110: (int<10>, int<10>, int<10>) = e1118
	let shift_red: int<10> = IndexTuple(0, [Int(10), Int(10), Int(10)])(e1110)
	let shift_green: int<10> = IndexTuple(1, [Int(10), Int(10), Int(10)])(e1110)
	let shift_blue: int<10> = IndexTuple(2, [Int(10), Int(10), Int(10)])(e1110)
	let e1139: int<2> = Truncate(shift_red)
	let e1141: int<2> = Truncate(shift_green)
	let e1143: int<2> = Truncate(shift_blue)
	let e1145: int<2> = Truncate(shift_clock)
	let e1138: {r: int<2>, g: int<2>, b: int<2>, clock: int<2>} = ConstructTuple(e1139, e1141, e1143, e1145)
} => e1138

entity \std::cdc::unsafe::sync2[497] ((clk, clk, bool), (in, in, bool)) -> bool {
	reg(clk) sync1: bool = in
	reg(clk) sync2: bool = sync1
} => sync2